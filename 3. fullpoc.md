### Full POC
---
Below are ready-to-apply OpenShift YAML manifests for the full POC consisting of 3 Python components:
- patch-agent-api (FastAPI)
- streamlit-ui (Streamlit)
- kb-service (KB REST API)

All manifests assume a dedicated namespace patching. Replace image names, registry references, and the AAP token value before applying. Save this full text to a file (e.g. patching-poc-all.yaml) and run oc apply -f patching-poc-all.yaml after doing the token step shown below.

---
#### Quick pre-apply steps (one-time)
- Create the namespace and secret (replace MY_AAP_TOKEN):
```bash
oc create namespace patching
oc -n patching create secret generic aap-token --from-literal=token='MY_AAP_TOKEN'
```
- Replace image names in the YAML (image: <your-registry/...>) with your built images or quay.io/... / docker.io/....
---
All-in-one OpenShift manifests (apply after replacing images & token):
```yml
# -----------------------------------------
# Namespace
# -----------------------------------------
apiVersion: v1
kind: Namespace
metadata:
  name: patching
---
# -----------------------------------------
# ConfigMap: application configuration
# -----------------------------------------
apiVersion: v1
kind: ConfigMap
metadata:
  name: patch-agent-config
  namespace: patching
data:
  # AAP Base API endpoint (example). Keep scheme + host and path to API v2 if required.
  AAP_BASE: "https://aap.example.com/api/v2"
  # API will call KB service via internal service name
  KB_URL: "http://kb-service:8080"
  # Streamlit will use this internal service URL for the API
  API_BASE_INTERNAL: "http://patch-agent-api:8000"
---
# -----------------------------------------
# Secret: AAP Token (created externally via oc create secret ...)
# -----------------------------------------
# NOTE: You already created this with:
# oc -n patching create secret generic aap-token --from-literal=token='MY_AAP_TOKEN'
# -----------------------------------------
---
# -----------------------------------------
# PersistentVolumeClaim for reports and KB data
# -----------------------------------------
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: patching-reports-pvc
  namespace: patching
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 5Gi
  storageClassName: "" # optional: set your cluster storageClass or remove line
---
# -----------------------------------------
# ServiceAccount (optional - use for RBAC)
# -----------------------------------------
apiVersion: v1
kind: ServiceAccount
metadata:
  name: patch-agent-sa
  namespace: patching
---
# -----------------------------------------
# Deployment: KB Service (Flask/FastAPI simple KB)
# mounts PVC at /data to store kb.json and allow editing persistence
# -----------------------------------------
apiVersion: apps/v1
kind: Deployment
metadata:
  name: kb-service
  namespace: patching
  labels:
    app: kb-service
spec:
  replicas: 1
  selector:
    matchLabels:
      app: kb-service
  template:
    metadata:
      labels:
        app: kb-service
    spec:
      serviceAccountName: patch-agent-sa
      containers:
      - name: kb-service
        image: your-registry/kb-service:latest   # <-- REPLACE with your image
        imagePullPolicy: IfNotPresent
        ports:
        - containerPort: 8080
        env:
        - name: KB_FILE_PATH
          value: "/data/kb.json"
        volumeMounts:
        - name: data
          mountPath: /data
        livenessProbe:
          httpGet:
            path: /health
            port: 8080
          initialDelaySeconds: 10
          periodSeconds: 20
      volumes:
      - name: data
        persistentVolumeClaim:
          claimName: patching-reports-pvc
---
apiVersion: v1
kind: Service
metadata:
  name: kb-service
  namespace: patching
spec:
  selector:
    app: kb-service
  ports:
  - protocol: TCP
    port: 8080
    targetPort: 8080
---
# -----------------------------------------
# Deployment: Patch Agent API (FastAPI)
# mounts PVC at /data/reports for storing generated reports
# -----------------------------------------
apiVersion: apps/v1
kind: Deployment
metadata:
  name: patch-agent-api
  namespace: patching
  labels:
    app: patch-agent-api
spec:
  replicas: 1
  selector:
    matchLabels:
      app: patch-agent-api
  template:
    metadata:
      labels:
        app: patch-agent-api
    spec:
      serviceAccountName: patch-agent-sa
      containers:
      - name: patch-agent-api
        image: your-registry/patch-agent-api:latest   # <-- REPLACE with your image
        imagePullPolicy: IfNotPresent
        ports:
        - containerPort: 8000
        env:
        - name: AAP_BASE
          valueFrom:
            configMapKeyRef:
              name: patch-agent-config
              key: AAP_BASE
        - name: KB_URL
          valueFrom:
            configMapKeyRef:
              name: patch-agent-config
              key: KB_URL
        - name: FILES_DIR
          value: "/data/reports"
        - name: AAP_TOKEN
          valueFrom:
            secretKeyRef:
              name: aap-token
              key: token
        volumeMounts:
        - name: reports
          mountPath: /data/reports
        readinessProbe:
          httpGet:
            path: /health
            port: 8000
          initialDelaySeconds: 5
          periodSeconds: 10
      volumes:
      - name: reports
        persistentVolumeClaim:
          claimName: patching-reports-pvc
---
apiVersion: v1
kind: Service
metadata:
  name: patch-agent-api
  namespace: patching
spec:
  selector:
    app: patch-agent-api
  ports:
  - protocol: TCP
    port: 8000
    targetPort: 8000
---
# -----------------------------------------
# Route: patch-agent-api (expose API externally if desired)
# -----------------------------------------
apiVersion: route.openshift.io/v1
kind: Route
metadata:
  name: patch-agent-api-route
  namespace: patching
spec:
  to:
    kind: Service
    name: patch-agent-api
  port:
    targetPort: 8000
  tls:
    termination: edge
---
# -----------------------------------------
# Deployment: Streamlit UI
# mounts nothing persistent (stateless); reads API_INTERNAL from configmap
# -----------------------------------------
apiVersion: apps/v1
kind: Deployment
metadata:
  name: streamlit-ui
  namespace: patching
  labels:
    app: streamlit-ui
spec:
  replicas: 1
  selector:
    matchLabels:
      app: streamlit-ui
  template:
    metadata:
      labels:
        app: streamlit-ui
    spec:
      serviceAccountName: patch-agent-sa
      containers:
      - name: streamlit-ui
        image: your-registry/streamlit-ui:latest   # <-- REPLACE with your image
        imagePullPolicy: IfNotPresent
        ports:
        - containerPort: 8501
        env:
        - name: API_BASE
          valueFrom:
            configMapKeyRef:
              name: patch-agent-config
              key: API_BASE_INTERNAL
        livenessProbe:
          httpGet:
            path: /
            port: 8501
          initialDelaySeconds: 10
          periodSeconds: 20
---
apiVersion: v1
kind: Service
metadata:
  name: streamlit-ui
  namespace: patching
spec:
  selector:
    app: streamlit-ui
  ports:
  - protocol: TCP
    port: 8501
    targetPort: 8501
---
# -----------------------------------------
# Route: streamlit UI (public route)
# -----------------------------------------
apiVersion: route.openshift.io/v1
kind: Route
metadata:
  name: streamlit-ui-route
  namespace: patching
spec:
  to:
    kind: Service
    name: streamlit-ui
  port:
    targetPort: 8501
  tls:
    termination: edge
---
# -----------------------------------------
# (Optional) NetworkPolicy stub - allow internal namespace traffic only
# Adjust depending on your cluster/network setup
# -----------------------------------------
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: allow-from-namespace-patching
  namespace: patching
spec:
  podSelector: {}
  policyTypes:
  - Ingress
  ingress:
  - from:
    - namespaceSelector:
        matchLabels:
          name: patching
```
---
Post-deploy actions & notes:
- Create initial KB file on the PVC so KB service has kb.json: You can oc rsh into the KB pod and create /data/kb.json containing [] or seed entries:
```bash
oc -n patching rsh deploy/kb-service
echo '[]' > /data/kb.json
exit
```
- Service URLs:
  - Streamlit external: https://streamlit-ui-route-patching.apps.<cluster> (route created).
  - API external: https://patch-agent-api-route-patching.apps.<cluster> (route created).
  - Internally streamlit-ui calls the API using API_BASE_INTERNAL (configmap), which points to the in-cluster service.
- Secrets: If you rotate AAP token later, update the secret:
```bash
oc -n patching create secret generic aap-token --from-literal=token='NEW' -o yaml --dry-run=client | oc replace -f -
```
- Images: Build Docker images for patch-agent-api, streamlit-ui, kb-service and push them to your registry accessible by OpenShift. Update the image fields in the YAML.
- Health endpoints: Implement /health in each app (FastAPI, KB service, Streamlit can just return 200) so probes succeed.
- Worker / Async: This POC uses a synchronous finalize endpoint. For production, add a Celery worker and Redis as separate Deployments and update FastAPI to enqueue jobs; Worker will process events and write reports.
- Security: Use OpenShift OAuth for UI/API auth, and limit which users can call /run. Use RoleBindings and ServiceAccounts for least privilege when accessing the PVC/Secrets.
